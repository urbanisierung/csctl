#!/usr/bin/env bash

set -Eeuo pipefail

# ── Constants ────────────────────────────────────────────────────────────────
CLI_NAME="csctl"
CONFIG_DIR="$HOME/.config/csctl"
STATE_FILE="$CONFIG_DIR/state"
REPO_DIR="$CONFIG_DIR/camunda-deployment-references"
WORK_DIR="$REPO_DIR/local/kubernetes/kind-single-region"
CSCTL_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
DEPLOY_REPO_URL="https://github.com/camunda/camunda-deployment-references.git"

# ── Defaults ─────────────────────────────────────────────────────────────────
DEFAULT_REF="stable/8.8"
DEFAULT_CLUSTER="camunda-platform-local"
DEFAULT_NAMESPACE="camunda-platform"
DEFAULT_RELEASE="camunda-platform"
DEFAULT_HOST="camunda.example.com"

# ── Colors ───────────────────────────────────────────────────────────────────
setup_colors() {
  if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
    RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' NOFORMAT='\033[0m'
  else
    RED='' GREEN='' YELLOW='' BLUE='' NOFORMAT=''
  fi
}
setup_colors

# ── Globals ──────────────────────────────────────────────────────────────────
VERBOSE=0
SPINNER_PID=""

# ── Helpers ──────────────────────────────────────────────────────────────────
msg()  { echo >&2 -e "${1-}"; }
die()  { msg "${RED}Error: ${1-}${NOFORMAT}"; exit "${2:-1}"; }

cleanup() {
  stop_spinner
}
trap cleanup EXIT

# ── Spinner ──────────────────────────────────────────────────────────────────
start_spinner() {
  if [[ "$VERBOSE" -eq 1 ]]; then
    msg "${BLUE}▶ ${1-}${NOFORMAT}"
    return
  fi
  local label="$1"
  (
    local chars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0
    while true; do
      printf '\r\033[K  %s %s' "${chars:i%${#chars}:1}" "$label" >&2
      i=$((i + 1))
      sleep 0.1
    done
  ) &
  SPINNER_PID=$!
}

stop_spinner() {
  if [[ -n "${SPINNER_PID-}" ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
    SPINNER_PID=""
    printf '\r\033[K' >&2
  fi
}

complete_step() {
  stop_spinner
  if [[ "$VERBOSE" -eq 0 ]]; then
    msg "  ${GREEN}✓${NOFORMAT} ${1-}"
  fi
}

fail_step() {
  stop_spinner
  msg "  ${RED}✗${NOFORMAT} ${1-}"
  if [[ -n "${2-}" && -f "$2" ]]; then
    msg "${RED}── Output ──${NOFORMAT}"
    cat "$2" >&2
    msg "${RED}────────────${NOFORMAT}"
  fi
}

run_step() {
  local label="$1"
  shift
  local log
  log=$(mktemp)
  start_spinner "$label"
  if [[ "$VERBOSE" -eq 1 ]]; then
    if "$@" 2>&1 | tee "$log"; then
      complete_step "$label"
      rm -f "$log"
      return 0
    else
      fail_step "$label"
      rm -f "$log"
      return 1
    fi
  else
    if "$@" >"$log" 2>&1; then
      complete_step "$label"
      rm -f "$log"
      return 0
    else
      fail_step "$label" "$log"
      rm -f "$log"
      return 1
    fi
  fi
}

# ── Usage ────────────────────────────────────────────────────────────────────
usage() {
  cat <<EOF
Usage: $CLI_NAME <command> [flags]

Commands:
  install       Install Camunda 8 locally (domain mode by default)
  delete        Delete the local Camunda 8 installation
  credentials   Print admin credentials
  port-forward  Forward ports to local services

Global flags:
  -h, --help      Show help
  -v, --verbose   Show full output instead of spinner UI

Run '$CLI_NAME <command> --help' for command-specific help.
EOF
}

usage_install() {
  cat <<EOF
Usage: $CLI_NAME install [flags]

Flags:
  --no-domain          Use no-domain (port-forward) mode instead of domain mode
  --ref <branch/tag>   Git ref for camunda-deployment-references (default: $DEFAULT_REF)
  --cluster <name>     Kind cluster name (default: $DEFAULT_CLUSTER)
  --namespace <name>   Kubernetes namespace (default: $DEFAULT_NAMESPACE)
  --release <name>     Helm release name (default: $DEFAULT_RELEASE)
  --host <hostname>    Hostname for domain mode (default: $DEFAULT_HOST)
  -p <profile>         Profile from extra-values/ (repeatable)
  -f <file>            Additional Helm values file (repeatable)
  -v, --verbose        Show full output
  -h, --help           Show this help
EOF
}

usage_delete() {
  cat <<EOF
Usage: $CLI_NAME delete [flags]

Flags:
  -v, --verbose   Show full output
  -h, --help      Show this help
EOF
}

usage_credentials() {
  cat <<EOF
Usage: $CLI_NAME credentials [flags]

Flags:
  -v, --verbose   Show full output
  -h, --help      Show this help
EOF
}

usage_portforward() {
  cat <<EOF
Usage: $CLI_NAME port-forward [flags]

Flags:
  -v, --verbose   Show full output
  -h, --help      Show this help
EOF
}

# ── Prerequisites ────────────────────────────────────────────────────────────
check_prerequisites() {
  local missing=()
  for tool in docker kind kubectl helm git; do
    command -v "$tool" &>/dev/null || missing+=("$tool")
  done
  if [[ "${1-}" != "no-domain" ]]; then
    command -v mkcert &>/dev/null || missing+=("mkcert")
  fi
  if [[ ${#missing[@]} -gt 0 ]]; then
    die "Missing required tools: ${missing[*]}. Please install them first."
  fi
}

# ── State file ───────────────────────────────────────────────────────────────
load_state() {
  if [[ ! -f "$STATE_FILE" ]]; then
    die "No csctl state found. Run 'csctl install' first."
  fi
  # shellcheck disable=SC1090
  source "$STATE_FILE"
}

write_state() {
  mkdir -p "$CONFIG_DIR"
  cat >"$STATE_FILE" <<EOF
MODE="$MODE"
CLUSTER_NAME="$CLUSTER_NAME"
NAMESPACE="$NAMESPACE"
RELEASE_NAME="$RELEASE_NAME"
REF="$REF"
HOST="$HOST"
EOF
}

# ── Env var exports for reference repo scripts ───────────────────────────────
export_env() {
  export CLUSTER_NAME
  export CAMUNDA_NAMESPACE="$NAMESPACE"
  export CAMUNDA_RELEASE_NAME="$RELEASE_NAME"
  export CERT_DIR="$WORK_DIR/.certs/"
}

# ── Clone / update reference repo ───────────────────────────────────────────
setup_repo() {
  local ref="$1"
  if [[ -d "$REPO_DIR/.git" ]]; then
    git -C "$REPO_DIR" fetch --all --quiet
  else
    mkdir -p "$REPO_DIR"
    git clone --quiet "$DEPLOY_REPO_URL" "$REPO_DIR"
  fi
  git -C "$REPO_DIR" checkout --quiet "$ref"
}

# ── Extract Helm chart version ───────────────────────────────────────────────
get_chart_version() {
  local mode="$1"
  local script_name
  if [[ "$mode" == "domain" ]]; then
    script_name="$WORK_DIR/procedure/camunda-deploy-domain.sh"
  else
    script_name="$WORK_DIR/procedure/camunda-deploy-no-domain.sh"
  fi
  if [[ ! -f "$script_name" ]]; then
    die "Could not determine Helm chart version from reference repo. Re-run with --ref to specify a valid branch."
  fi
  local version
  version=$(sed -n 's/.*CAMUNDA_HELM_CHART_VERSION=\([^ ]*\).*/\1/p' "$script_name" | head -1)
  if [[ -z "$version" ]]; then
    die "Could not determine Helm chart version from reference repo. Re-run with --ref to specify a valid branch."
  fi
  echo "$version"
}

# ── /etc/hosts management ───────────────────────────────────────────────────
add_hosts_entry() {
  local hostname="$1"
  if grep -qF "127.0.0.1 ${hostname}" /etc/hosts 2>/dev/null; then
    return 0
  fi
  msg ""
  msg "${YELLOW}csctl needs to add '127.0.0.1 ${hostname}' to /etc/hosts.${NOFORMAT}"
  read -rp "Add entry to /etc/hosts? [y/N] " answer
  if [[ "$answer" =~ ^[Yy]$ ]]; then
    echo "127.0.0.1 ${hostname}" | sudo tee -a /etc/hosts >/dev/null
    msg "  ${GREEN}✓${NOFORMAT} Added ${hostname} to /etc/hosts"
  else
    msg "${YELLOW}Please add the following line to /etc/hosts manually:${NOFORMAT}"
    msg "  127.0.0.1 ${hostname}"
  fi
}

remove_hosts_entry() {
  local hostname="$1"
  local escaped_hostname
  escaped_hostname=$(printf '%s' "$hostname" | sed 's/[.[\*^$()+?{|]/\\&/g')
  if grep -qF "127.0.0.1 ${hostname}" /etc/hosts 2>/dev/null; then
    sudo sed -i "/^127\.0\.0\.1[[:space:]]\+${escaped_hostname}$/d" /etc/hosts
    msg "  ${GREEN}✓${NOFORMAT} Removed ${hostname} from /etc/hosts"
  fi
}

# ── Parse global flags from any position ─────────────────────────────────────
parse_global_flags() {
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -v|--verbose) VERBOSE=1 ;;
      *) args+=("$1") ;;
    esac
    shift
  done
  REMAINING_ARGS=("${args[@]+"${args[@]}"}")
}

# ══════════════════════════════════════════════════════════════════════════════
# ── INSTALL ──────────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════
cmd_install() {
  # Defaults
  MODE="domain"
  CLUSTER_NAME="$DEFAULT_CLUSTER"
  NAMESPACE="$DEFAULT_NAMESPACE"
  RELEASE_NAME="$DEFAULT_RELEASE"
  HOST="$DEFAULT_HOST"
  REF="$DEFAULT_REF"
  local profiles=()
  local extra_files=()

  # Parse install flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help) usage_install; exit 0 ;;
      --no-domain) MODE="no-domain" ;;
      --ref) REF="${2:?'--ref requires a value'}"; shift ;;
      --cluster) CLUSTER_NAME="${2:?'--cluster requires a value'}"; shift ;;
      --namespace) NAMESPACE="${2:?'--namespace requires a value'}"; shift ;;
      --release) RELEASE_NAME="${2:?'--release requires a value'}"; shift ;;
      --host) HOST="${2:?'--host requires a value'}"; shift ;;
      -p) profiles+=("${2:?'-p requires a profile name'}"); shift ;;
      -f) extra_files+=("${2:?'-f requires a file path'}"); shift ;;
      *) die "Unknown option: $1" ;;
    esac
    shift
  done

  # Validate inputs (alphanumeric, hyphens, dots only)
  local name_re='^[a-zA-Z0-9._-]+$'
  [[ "$CLUSTER_NAME" =~ $name_re ]] || die "Invalid cluster name: '$CLUSTER_NAME' (use alphanumeric, hyphens, dots only)"
  [[ "$NAMESPACE" =~ $name_re ]]    || die "Invalid namespace: '$NAMESPACE' (use alphanumeric, hyphens, dots only)"
  [[ "$RELEASE_NAME" =~ $name_re ]] || die "Invalid release name: '$RELEASE_NAME' (use alphanumeric, hyphens, dots only)"
  [[ "$HOST" =~ $name_re ]]         || die "Invalid hostname: '$HOST' (use alphanumeric, hyphens, dots only)"

  # ── Prerequisites ──
  local prereq_mode="domain"
  [[ "$MODE" == "no-domain" ]] && prereq_mode="no-domain"
  check_prerequisites "$prereq_mode"

  msg "${BLUE}Installing Camunda 8 (${MODE} mode)${NOFORMAT}"
  msg ""

  # ── Clone/update reference repo ──
  run_step "Cloning/updating deployment references (${REF})" setup_repo "$REF" \
    || die "Failed to clone/update reference repo."

  # ── Extract Helm chart version ──
  local chart_version
  chart_version=$(get_chart_version "$MODE") \
    || die "Failed to extract Helm chart version."
  if [[ "$VERBOSE" -eq 1 ]]; then
    msg "  Helm chart version: ${chart_version}"
  fi

  # ── Helm repo setup ──
  run_step "Setting up Helm repo" bash -c 'helm repo add camunda https://helm.camunda.io --force-update && helm repo update camunda' \
    || die "Failed to set up Helm repo."

  # ── Export env vars ──
  export_env

  # ── Kind cluster creation ──
  run_step "Creating Kind cluster (${CLUSTER_NAME})" bash -c "cd '$WORK_DIR' && bash procedure/setup-kind.sh" \
    || die "Failed to create Kind cluster."

  # ── Ingress setup ──
  run_step "Setting up ingress" bash -c "cd '$WORK_DIR' && bash procedure/setup-ingress.sh" \
    || die "Failed to set up ingress."

  # ── mkcert setup (domain mode only) ──
  if [[ "$MODE" == "domain" ]]; then
    run_step "Setting up mkcert certificates" bash -c "cd '$WORK_DIR' && bash procedure/setup-mkcert.sh" \
      || die "Failed to set up mkcert."
  fi

  # ── Write state file ──
  write_state
  complete_step "State file written"

  # ── Assemble Helm values files ──
  local helm_args=()
  helm_args+=(upgrade --install "$RELEASE_NAME" camunda/camunda-platform)
  helm_args+=(--namespace "$NAMESPACE" --create-namespace)
  helm_args+=(--version "$chart_version")

  # 1. Reference repo base values
  if [[ "$MODE" == "domain" ]]; then
    helm_args+=(--values "$WORK_DIR/helm-values/values-domain.yml")
    # 2. mkcert values (domain mode only)
    helm_args+=(--values "$WORK_DIR/helm-values/values-mkcert.yml")
  else
    helm_args+=(--values "$WORK_DIR/helm-values/values-no-domain.yml")
  fi

  # 3. Profile files
  for profile in "${profiles[@]+"${profiles[@]}"}"; do
    local profile_file="$CSCTL_ROOT/extra-values/${profile}.yaml"
    if [[ ! -f "$profile_file" ]]; then
      die "Profile not found: ${profile_file}"
    fi
    helm_args+=(--values "$profile_file")
  done

  # 4. User-supplied extra files
  for f in "${extra_files[@]+"${extra_files[@]}"}"; do
    if [[ ! -f "$f" ]]; then
      die "Values file not found: ${f}"
    fi
    helm_args+=(--values "$f")
  done

  # ── Helm install ──
  run_step "Installing Camunda 8 via Helm (v${chart_version})" helm "${helm_args[@]}" \
    || die "Helm install failed."

  # ── /etc/hosts ──
  if [[ "$MODE" == "domain" ]]; then
    add_hosts_entry "$HOST"
  else
    add_hosts_entry "camunda-keycloak"
  fi

  # ── Post-install output ──
  msg ""
  msg "${GREEN}✓ Camunda 8 installed successfully!${NOFORMAT}"
  msg ""

  # Print credentials
  print_credentials_info

  # Print access info
  if [[ "$MODE" == "domain" ]]; then
    msg "${BLUE}Access:${NOFORMAT} https://${HOST}/"
  else
    msg "${BLUE}Access:${NOFORMAT} Run '$CLI_NAME port-forward' to forward ports."
  fi
}

print_credentials_info() {
  local password
  password=$(kubectl get secret "${RELEASE_NAME}-keycloak" -n "${NAMESPACE}" -o jsonpath='{.data.admin-password}' 2>/dev/null | base64 -d 2>/dev/null) || true
  if [[ -n "$password" ]]; then
    msg "${BLUE}Credentials:${NOFORMAT}"
    msg "  Username: admin"
    msg "  Password: ${password}"
  else
    msg "${YELLOW}Credentials not yet available (pods may still be starting).${NOFORMAT}"
    msg "  Run '$CLI_NAME credentials' once pods are ready."
  fi
}

# ══════════════════════════════════════════════════════════════════════════════
# ── DELETE ───────────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════
cmd_delete() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help) usage_delete; exit 0 ;;
      *) die "Unknown option: $1" ;;
    esac
    shift
  done

  load_state
  export_env

  msg "${BLUE}Deleting Camunda 8 installation (${MODE} mode)${NOFORMAT}"
  msg ""

  # Helm uninstall
  run_step "Uninstalling Helm release (${RELEASE_NAME})" \
    helm uninstall "$RELEASE_NAME" --namespace "$NAMESPACE" || \
    die "Failed to uninstall Helm release. State file preserved at ${STATE_FILE}."

  # Kind delete cluster
  run_step "Deleting Kind cluster (${CLUSTER_NAME})" \
    kind delete cluster --name "$CLUSTER_NAME" || \
    die "Failed to delete Kind cluster. State file preserved at ${STATE_FILE}."

  # /etc/hosts cleanup (called directly, not via run_step, because it prompts interactively)
  if [[ "$MODE" == "domain" ]]; then
    remove_hosts_entry "$HOST"
    # Remove certs
    if [[ -d "$WORK_DIR/.certs" ]]; then
      rm -rf "$WORK_DIR/.certs"
    fi
  else
    remove_hosts_entry "camunda-keycloak"
  fi

  # Delete state file only after successful teardown
  rm -f "$STATE_FILE"
  complete_step "State file removed"

  msg ""
  msg "${GREEN}✓ Camunda 8 deleted successfully.${NOFORMAT}"
}

# ══════════════════════════════════════════════════════════════════════════════
# ── CREDENTIALS ──────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════
cmd_credentials() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help) usage_credentials; exit 0 ;;
      *) die "Unknown option: $1" ;;
    esac
    shift
  done

  load_state

  local password
  password=$(kubectl get secret "${RELEASE_NAME}-keycloak" -n "${NAMESPACE}" -o jsonpath='{.data.admin-password}' 2>/dev/null | base64 -d 2>/dev/null) || true
  if [[ -z "$password" ]]; then
    die "Could not retrieve credentials. Is the cluster running?"
  fi

  msg "Username: admin"
  msg "Password: ${password}"
}

# ══════════════════════════════════════════════════════════════════════════════
# ── PORT-FORWARD ─────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════
cmd_port_forward() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help) usage_portforward; exit 0 ;;
      *) die "Unknown option: $1" ;;
    esac
    shift
  done

  load_state
  export_env

  if [[ "$MODE" == "domain" ]]; then
    msg "${YELLOW}Warning: port-forward is intended for no-domain mode. In domain mode, services are accessible via https://${HOST}/.${NOFORMAT}"
  fi

  msg "${BLUE}Starting port-forward...${NOFORMAT}"
  cd "$WORK_DIR"
  bash procedure/port-forward.sh
}

# ══════════════════════════════════════════════════════════════════════════════
# ── MAIN ─────────────────────────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════════════════════
main() {
  # Handle empty invocation
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  # Extract global flags first, preserving subcommand and its flags
  parse_global_flags "$@"
  set -- "${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}"

  # Handle top-level help
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  local command="$1"
  shift

  # Detect top-level options that aren't help flags (e.g. csctl -f foo.yaml)
  if [[ "$command" == -* && "$command" != "-h" && "$command" != "--help" ]]; then
    die "Unknown option or missing subcommand. Run '$CLI_NAME --help' for usage."
  fi

  case "$command" in
    install)      cmd_install "$@" ;;
    delete)       cmd_delete "$@" ;;
    credentials)  cmd_credentials "$@" ;;
    port-forward) cmd_port_forward "$@" ;;
    -h|--help)    usage; exit 0 ;;
    *)            die "Unknown command: ${command}. Run '$CLI_NAME --help' for usage." ;;
  esac
}

main "$@"
